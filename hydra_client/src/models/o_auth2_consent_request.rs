/* 
 * Hydra OAuth2 & OpenID Connect Server
 *
 * Please refer to the user guide for in-depth documentation: https://ory.gitbooks.io/hydra/content/   Hydra offers OAuth 2.0 and OpenID Connect Core 1.0 capabilities as a service. Hydra is different, because it works with any existing authentication infrastructure, not just LDAP or SAML. By implementing a consent app (works with any programming language) you build a bridge between Hydra and your authentication infrastructure. Hydra is able to securely manage JSON Web Keys, and has a sophisticated policy-based access control you can use if you want to. Hydra is suitable for green- (new) and brownfield (existing) projects. If you are not familiar with OAuth 2.0 and are working on a greenfield project, we recommend evaluating if OAuth 2.0 really serves your purpose. Knowledge of OAuth 2.0 is imperative in understanding what Hydra does and how it works.   The official repository is located at https://github.com/ory/hydra   ### Important REST API Documentation Notes  The swagger generator used to create this documentation does currently not support example responses. To see request and response payloads click on **\"Show JSON schema\"**: ![Enable JSON Schema on Apiary](https://storage.googleapis.com/ory.am/hydra/json-schema.png)   The API documentation always refers to the latest tagged version of ORY Hydra. For previous API documentations, please refer to https://github.com/ory/hydra/blob/<tag-id>/docs/api.swagger.yaml - for example:  0.9.13: https://github.com/ory/hydra/blob/v0.9.13/docs/api.swagger.yaml 0.8.1: https://github.com/ory/hydra/blob/v0.8.1/docs/api.swagger.yaml
 *
 * OpenAPI spec version: Latest
 * Contact: hi@ory.am
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct OAuth2ConsentRequest {
  /// ClientID is the client id that initiated the OAuth2 request.
  #[serde(rename = "clientId")]
  client_id: Option<String>,
  /// ExpiresAt is the time where the access request will expire.
  #[serde(rename = "expiresAt")]
  expires_at: Option<String>,
  /// ID is the id of this consent request.
  #[serde(rename = "id")]
  id: Option<String>,
  /// RedirectURL is the URL where the user agent should be redirected to after the consent has been accepted or rejected.
  #[serde(rename = "redirectUrl")]
  redirect_url: Option<String>,
  /// RequestedAuthenticationContextClassReference specifies an Authentication Context Class Reference value that identifies the Authentication Context Class that the authentication performed satisfied. The value \"0\" indicates the End-User authentication did not meet the requirements of ISO/IEC 29115 [ISO29115] level 1.  In summary ISO/IEC 29115 defines four levels, broadly summarized as follows.  acr=0 does not satisfy Level 1 and could be, for example, authentication using a long-lived browser cookie. Level 1 (acr=1): Minimal confidence in the asserted identity of the entity, but enough confidence that the entity is the same over consecutive authentication events. For example presenting a self-registered username or password. Level 2 (acr=2): There is some confidence in the asserted identity of the entity. For example confirming authentication using a mobile app (\"Something you have\"). Level 3 (acr=3): High confidence in an asserted identity of the entity. For example sending a code to a mobile phone or using Google Authenticator or a fingerprint scanner (\"Something you have and something you know\" / \"Something you are\") Level 4 (acr=4): Very high confidence in an asserted identity of the entity. Requires in-person identification.
  #[serde(rename = "requestedAcr")]
  requested_acr: Option<Vec<String>>,
  /// MaxAge specifies the allowable elapsed time in seconds since the last time the End-User was actively authenticated by the OP. If the elapsed time is greater than this value, the OP MUST attempt to actively re-authenticate the End-User.
  #[serde(rename = "requestedMaxAge")]
  requested_max_age: Option<i64>,
  /// Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for reauthentication and consent. The defined values are:  none: The consent app MUST NOT display any authentication or consent user interface pages. An error is returned if an End-User is not already authenticated or the Client does not have pre-configured consent for the requested Claims or does not fulfill other conditions for processing the request. The error code will typically be login_required, interaction_required. This can be used as a method to check for existing authentication and/or consent. login: The consent app SHOULD prompt the End-User for reauthentication. If it cannot reauthenticate the End-User, it MUST return an error, typically login_required. consent: The consent app SHOULD prompt the End-User for consent before returning information to the Client. If it cannot obtain consent, it MUST return an error, typically consent_required. select_account: The consent app SHOULD prompt the End-User to select a user account. This enables an End-User who has multiple accounts at the Authorization Server to select amongst the multiple accounts that they might have current sessions for. If it cannot obtain an account selection choice made by the End-User, it MUST return an error, typically account_selection_required.  The prompt parameter can be used by the Client to make sure that the End-User is still present for the current session or to bring attention to the request. If this parameter contains none with any other value, an error is returned.
  #[serde(rename = "requestedPrompt")]
  requested_prompt: Option<String>,
  /// RequestedScopes represents a list of scopes that have been requested by the OAuth2 request initiator.
  #[serde(rename = "requestedScopes")]
  requested_scopes: Option<Vec<String>>
}

impl OAuth2ConsentRequest {
  pub fn new() -> OAuth2ConsentRequest {
    OAuth2ConsentRequest {
      client_id: None,
      expires_at: None,
      id: None,
      redirect_url: None,
      requested_acr: None,
      requested_max_age: None,
      requested_prompt: None,
      requested_scopes: None
    }
  }

  pub fn set_client_id(&mut self, client_id: String) {
    self.client_id = Some(client_id);
  }

  pub fn with_client_id(mut self, client_id: String) -> OAuth2ConsentRequest {
    self.client_id = Some(client_id);
    self
  }

  pub fn client_id(&self) -> Option<&String> {
    self.client_id.as_ref()
  }

  pub fn reset_client_id(&mut self) {
    self.client_id = None;
  }

  pub fn set_expires_at(&mut self, expires_at: String) {
    self.expires_at = Some(expires_at);
  }

  pub fn with_expires_at(mut self, expires_at: String) -> OAuth2ConsentRequest {
    self.expires_at = Some(expires_at);
    self
  }

  pub fn expires_at(&self) -> Option<&String> {
    self.expires_at.as_ref()
  }

  pub fn reset_expires_at(&mut self) {
    self.expires_at = None;
  }

  pub fn set_id(&mut self, id: String) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: String) -> OAuth2ConsentRequest {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&String> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_redirect_url(&mut self, redirect_url: String) {
    self.redirect_url = Some(redirect_url);
  }

  pub fn with_redirect_url(mut self, redirect_url: String) -> OAuth2ConsentRequest {
    self.redirect_url = Some(redirect_url);
    self
  }

  pub fn redirect_url(&self) -> Option<&String> {
    self.redirect_url.as_ref()
  }

  pub fn reset_redirect_url(&mut self) {
    self.redirect_url = None;
  }

  pub fn set_requested_acr(&mut self, requested_acr: Vec<String>) {
    self.requested_acr = Some(requested_acr);
  }

  pub fn with_requested_acr(mut self, requested_acr: Vec<String>) -> OAuth2ConsentRequest {
    self.requested_acr = Some(requested_acr);
    self
  }

  pub fn requested_acr(&self) -> Option<&Vec<String>> {
    self.requested_acr.as_ref()
  }

  pub fn reset_requested_acr(&mut self) {
    self.requested_acr = None;
  }

  pub fn set_requested_max_age(&mut self, requested_max_age: i64) {
    self.requested_max_age = Some(requested_max_age);
  }

  pub fn with_requested_max_age(mut self, requested_max_age: i64) -> OAuth2ConsentRequest {
    self.requested_max_age = Some(requested_max_age);
    self
  }

  pub fn requested_max_age(&self) -> Option<&i64> {
    self.requested_max_age.as_ref()
  }

  pub fn reset_requested_max_age(&mut self) {
    self.requested_max_age = None;
  }

  pub fn set_requested_prompt(&mut self, requested_prompt: String) {
    self.requested_prompt = Some(requested_prompt);
  }

  pub fn with_requested_prompt(mut self, requested_prompt: String) -> OAuth2ConsentRequest {
    self.requested_prompt = Some(requested_prompt);
    self
  }

  pub fn requested_prompt(&self) -> Option<&String> {
    self.requested_prompt.as_ref()
  }

  pub fn reset_requested_prompt(&mut self) {
    self.requested_prompt = None;
  }

  pub fn set_requested_scopes(&mut self, requested_scopes: Vec<String>) {
    self.requested_scopes = Some(requested_scopes);
  }

  pub fn with_requested_scopes(mut self, requested_scopes: Vec<String>) -> OAuth2ConsentRequest {
    self.requested_scopes = Some(requested_scopes);
    self
  }

  pub fn requested_scopes(&self) -> Option<&Vec<String>> {
    self.requested_scopes.as_ref()
  }

  pub fn reset_requested_scopes(&mut self) {
    self.requested_scopes = None;
  }

}



